# Codebase Deep Dive

This document provides an overview of every major file and module in the repository. It explains how the pieces fit together and highlights the most complex portion of the code. Reading this should give new contributors a solid understanding of the project architecture and where to implement improvements.

## Repository Layout

```
/
├── AGENTS.md              Development instructions for Codex
├── Makefile               Common development tasks
├── docs/                  Project documentation
├── design/                UI wireframes
├── scripts/               Setup and helper scripts
└── ytapp/                 Tauri application source
```

### Top Level Files

- **AGENTS.md** – Defines the required verification commands and overall guidelines. It instructs developers to run `npx ts-node --project ytapp/tsconfig.json scripts/generate-schema.ts`, `npm install`, `cargo check`, and `ts-node src/cli.ts --help` before committing. It also explains the devcontainer setup.
- **Makefile** – Implements the `verify`, `dev`, `test`, and `package` targets. `make verify` generates the shared schema then runs linting, TypeScript compilation, `cargo check`, and a CLI help check. The `test` target runs each TypeScript test sequentially; you can alternatively run `npm test` inside `ytapp`.
- **readme.md** – Extensive implementation plan covering every feature: audio processing, transcription, YouTube integration, batch tools, UI design, packaging, setup and CLI usage.
- **scripts/** – Contains bash and Node scripts used for setup, packaging and translation updates.
  - `setup.sh` installs toolchains and dependencies.
  - `setup_codex.sh` runs `setup.sh` and installs system packages on Linux.
  - `install_tauri_deps.sh` installs GTK/WebKit headers such as `libgtk-3-dev`,
    `libglib2.0-dev`, `libsoup2.4-dev`, `libwebkit2gtk-4.1-dev` and
    `libjavascriptcoregtk-4.1-dev` then writes `.env.tauri` with
    `PKG_CONFIG_PATH`.
  - `generate-schema.ts` generates TypeScript and Rust schema files from a common definition.

## Documentation (`docs/`)

The documentation folder hosts additional markdown references such as the design philosophy, Codex self‑reflection, prompt history and a guide for resolving merge conflicts. `docs/index.md` lists all available documents.

## Design Files (`design/`)

`design/wireframes` contains simple ASCII mockups describing the main UI flow and the batch processing screen. They provide a quick reference for the overall layout.

## Application Source (`ytapp/`)

The `ytapp` directory hosts both the frontend code (React/TypeScript) and the Rust backend under `src-tauri`.

### package.json and tsconfig.json

`package.json` defines dependencies and npm scripts. `tsconfig.json` configures TypeScript compilation, targeting ES2020 with strict settings.

### Frontend Code (`ytapp/src`)

- **App.tsx** – Main React component implementing the single video workflow. It manages state for file paths, caption settings, watermark options, generation progress, and integrates sub‑pages like batch tools, settings, profiles and logs. It listens for keyboard shortcuts, launches Tauri commands and shows modals such as the subtitle editor and onboarding dialog.
- **main.tsx** – Entry point that loads settings, checks dependencies and renders `<App />` to the DOM.
- **i18n.ts** – Minimal i18next setup. Translation JSON files under `public/locales` are eagerly imported and used to initialize the library.
- **schema.ts** – Interfaces shared between the frontend and backend. Generated by `scripts/generate-schema.ts` to keep TypeScript and Rust structures in sync.
- **cli.ts** – Implements the command line interface. Uses `commander` to expose commands equivalent to the GUI functionality: generate video, upload, batch operations, queue management, profile handling and more. Progress is reported via Tauri events.
- **components/** – Reusable React components.
  - `FilePicker.tsx` and `DropZone.tsx` handle file selection and drag‑and‑drop.
  - `BatchProcessor.tsx`, `BatchUploader.tsx` and `BatchOptionsForm.tsx` implement batch generation and upload UIs.
  - `SettingsPage.tsx` persists default options (including default resolution) via the settings API.
  - `ProfilesPage.tsx` manages saved profiles.
  - `QueuePage.tsx` shows queued jobs and allows reordering.
  - `LogsPage.tsx` displays application logs.
  - Utility components like `FontSelector.tsx`, `LanguageSelector.tsx`, `SizeSlider.tsx`, and various icons round out the interface.
- **features/** – Small modules that wrap Tauri commands so they can be reused by both the GUI and CLI.
  - `processing` – Calls the `generate_video` command and listens for progress events.
  - `youtube` – Handles video uploads, OAuth sign‑in, playlist retrieval and batch upload helpers.
  - `transcription` – Invokes `transcribe_audio` and optionally translates subtitles with `argos-translate` via `utils/translate.ts`.
  - `batch` – Generates multiple videos in a row.
  - `queue.ts` – API for the background job queue (add/remove/move jobs, listen for updates).
  - `settings` – Load and save persistent settings on disk.
  - `logs.ts` – Retrieve log lines from the backend.
  - `watch.ts` – Start or stop directory watching.
- **utils/** – Helper functions.
  - `csv.ts` parses CSV metadata files for batch processing.
  - `notify.ts` sends desktop notifications with fallbacks for the web.
  - `translate.ts` spawns `argos-translate` to translate SRT files.
- **tests/** – Lightweight Node tests for the TypeScript modules.

### Backend Code (`ytapp/src-tauri`)

The Rust side exposes commands to the frontend via Tauri. Major files include:

- **main.rs** – Entry point and the most complex file in the project. It implements:
  - Video generation using FFmpeg, combining intro/outro segments, burning subtitles and applying watermarks while reporting progress.
  - YouTube upload logic using the Google API client, including thumbnail upload and playlist insertion.
  - Transcription via `whisper_cli` with optional model download checks.
  - Background job queue with pause/resume functionality and persistent storage.
  - Directory watching that enqueues new jobs when audio files appear.
  - Settings and profile management using JSON files under the app config directory.
  - Font enumeration across platforms, dependency verification and installation helpers.
  - Numerous Tauri commands such as `generate_video`, `upload_video`, `generate_upload`, `watch_directory`, `queue_*` operations and more.
- **schema.rs** – Mirror of `schema.ts` generated from `generate-schema.ts`.
- **language.rs** – Maps language codes to the `whisper_cli` `Language` enum. Includes unit tests.
- **model_check.rs** – Ensures the selected Whisper model is downloaded before the app runs.
- **token_store.rs** – Simple encrypted token storage used for OAuth tokens.
- **job_queue.rs** – In‑memory queue implementation with persistence to disk, job status tracking and worker control.
- **logger.rs** – Appends structured log entries to `ytapp.log` and exposes a command to read recent lines.
- **build.rs** and **Cargo.toml** – Standard Tauri build script and dependencies (Tauri, Whisper, YouTube API, etc.).

### `start_queue_worker`

This background task begins during application setup and whenever directory watching is enabled. It continuously loads the persisted queue and calls `dequeue` for the next job. Failed items are retried up to the configured limit before being marked failed, then a `queue_notify` event reports the result.

While a job runs, the generation and upload functions emit `queue_progress` events so the UI can update progress bars. When no work is available the worker waits for a notification, allowing new jobs or a resume command to wake it.

### Configuration

`tauri.conf.json` defines the application identifier, icon and enables the updater plugin. `Cargo.toml` and `package.json` lock dependency versions.

## Most Complex Code

`src-tauri/src/main.rs` is the heart of the application and easily the most complex file. It coordinates FFmpeg processes, manages asynchronous uploads with cancellation support, handles the job queue, watches directories for new files and deals with cross‑platform font discovery. Its responsibilities span media processing, network requests and filesystem management, making it the key piece for understanding backend behavior.

## Next Steps for Contributors

1. **Set up the environment** using `scripts/setup_codex.sh` or the devcontainer image. Source `.env.tauri` before running Rust commands. If `cargo check` complains about a missing `glib-2.0.pc`, run `scripts/install_tauri_deps.sh` (or install `libgtk-3-dev libglib2.0-dev libsoup2.4-dev libwebkit2gtk-4.1-dev libjavascriptcoregtk-4.1-dev`) and retry.
2. **Run `make verify`** (or the individual commands in `AGENTS.md`) to generate the shared schema and ensure TypeScript, Rust and CLI checks pass.
3. **Frontend changes** should go in `ytapp/src` – React components or feature modules. Keep indentation consistent (2 spaces for `.ts`, 4 for `.tsx`).
4. **Backend changes** belong under `ytapp/src-tauri/src`. Add new Tauri commands here and expose them through small wrappers under `src/features`.
5. **Add documentation** in `docs/` when introducing significant features.

With this understanding of the file layout and how the modules interact, new engineers can navigate the project confidently and start contributing improvements.
